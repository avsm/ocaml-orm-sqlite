# Makefile to build and run the test files in a variety of ways

P4INC = `ocamlfind query orm.syntax -predicates syntax,preprocessor -format "-I %d %a" -r`
PACKS= -package unix,sqlite3,oUnit,orm.syntax

TESTS := alltypes foreign_and_variant list_foreign list_simple nested_tuple simple_option \
	tuple variant_tuple simple_alltypes \
	array_simple foreign_nested list_list list_tuple recursive simple_twodefs variant \
	foreign foreign_tuple list_recursive nested_option simple variant_nested 
#	delete

.PHONY: all
all: $(TESTS:%=pr_%) $(TESTS:%=r_%) $(TESTS:%=pi_%) $(TESTS:%=i_%)
	@ :

# p_% prints out the process ML file to stdout
.PHONY: p_%
p_%:
	camlp4o $(P4INC) -parser o -printer o $*.ml

# top_% makes a top-level for the ML file
top_%: pc_%
	ocamlfind ocamlmktop $(PACKS) -linkpkg -o $@ -I ../ sql_access.cma pc_$*.cmo

# pc_% compiles it via a temporary ML file (pc_%.ml) so that locations in generated code can be
# seen in error messages as a debugging aid
pc_%: %.ml
	camlp4o $(P4INC) -printer o $*.ml > $@.ml
	ocamlfind ocamlc -verbose -linkpkg -g -annot -o $@ $(PACKS) $@.ml

# pr_% compiles and runs the code via the intermediate ML file
pr_%: pc_%
	@./$<

# c_% compiles the ML file directly by invoking camlp4 as -pp (how it is used in production)
c_%: %.ml
	ocamlfind ocamlc -verbose -o $@ -linkpkg -g $(PACKS) \
	  -pp "camlp4o $(P4INC) " $*.ml

nc_%: %.ml
	ocamlfind ocamlopt -o $@ -linkpkg $(PACKS) \
	  -pp "camlp4o $(P4INC) " $*.ml

# r_% runs the executable generated by directly compiling with the p4 extension
r_%: c_%
	@./$<

# i_% displays the inferred OCaml interface of the generated functions
.PHONY: i_%
i_%: %.ml
	ocamlfind ocamlc -i -verbose -linkpkg -g $(PACKS) \
	  -pp "camlp4o $(P4INC) " $*.ml

# pi_% prints to a temporary file and then displays the Ocaml interface
pi_%: %.ml
	camlp4o $(P4INC) -printer o $*.ml > $@.ml
	ocamlfind ocamlc -verbose -i -linkpkg -g $(PACKS) $@.ml
	
.PHONY: clean
clean:
	rm -f pc_* c_* pi_* *.cmo *.cma *.db *.cmi top_*
